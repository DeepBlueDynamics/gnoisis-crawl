"""
FastAPI Middleware for gnosis-crawl - Authentication and Content-Type enforcement.
"""
import os
import logging
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.types import ASGIApp

from app.tools.tool_registry import get_global_registry

logger = logging.getLogger(__name__)

class ContentTypeMiddleware(BaseHTTPMiddleware):
    """
    Ensures that every response has a Content-Type header.
    Defaults to application/json if no other content type is set.
    """
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        if "content-type" not in response.headers:
            response.headers["Content-Type"] = "application/json"
        return response


class AuthMiddleware(BaseHTTPMiddleware):
    """
    Authentication middleware that validates JWT tokens with auth service.
    """
    
    def __init__(self, app: ASGIApp):
        super().__init__(app)
        self.auth_client = None  # Lazy load to avoid init issues
    
    def _get_auth_client(self):
        """Lazy load auth client to avoid initialization issues"""
        if self.auth_client is None:
            try:
                from app.auth import auth_client
                self.auth_client = auth_client
            except Exception as e:
                logger.error(f"Failed to initialize auth client: {e}")
                raise HTTPException(status_code=500, detail="Authentication service unavailable")
        return self.auth_client
    
    async def dispatch(self, request: Request, call_next):
        # Skip auth for certain paths - CHECK THIS FIRST before any auth client access
        logger.debug(f"AuthMiddleware checking path: '{request.url.path}'")
        if request.url.path in ["/", "/health", "/tools", "/@search", "/auth", "/docs", "/redoc", "/openapi.json"]:
            logger.debug(f"Skipping auth for path: {request.url.path}")
            return await call_next(request)
        logger.debug(f"Requiring auth for path: {request.url.path}")
        
        # Extract bearer token from Authorization header
        auth_header = request.headers.get("Authorization", "")
        
        if not auth_header.startswith("Bearer "):
            # Check query params as fallback
            bearer_token = request.query_params.get("bearer_token")
            if not bearer_token:
                return JSONResponse(
                    status_code=401,
                    content={"error": "Missing bearer token"}
                )
        else:
            bearer_token = auth_header[7:]  # Remove "Bearer " prefix
        
        try:
            # Validate JWT token with auth service
            auth_client = self._get_auth_client()
            user_data = await auth_client.validate_token(bearer_token)
            
            # Attach auth context to request
            request.state.user = user_data
            request.state.bearer_token = bearer_token
            
            logger.debug(f"Authenticated user {user_data.get('subject', 'unknown')}")
            
        except Exception as e:
            logger.error(f"Authentication failed: {e}")
            return JSONResponse(
                status_code=401,
                content={"error": "Invalid or expired token"}
            )
        
        # Proceed with authenticated request
        response = await call_next(request)
        return response


# Create the combined auth middleware function for use in main.py
async def auth_middleware(request: Request, call_next):
    """
    Combined authentication middleware for backwards compatibility.
    Validates JWT tokens with auth service.
    """
    from app.auth import auth_client
    
    # Skip auth for certain paths
    if request.url.path in ["/", "/health", "/tools", "/@search", "/auth", "/docs", "/redoc", "/openapi.json"]:
        return await call_next(request)
    
    # Extract bearer token from Authorization header
    auth_header = request.headers.get("Authorization", "")
    
    if not auth_header.startswith("Bearer "):
        # Check query params as fallback
        bearer_token = request.query_params.get("bearer_token")
        if not bearer_token:
            return JSONResponse(
                status_code=401,
                content={"error": "Missing bearer token"}
            )
    else:
        bearer_token = auth_header[7:]  # Remove "Bearer " prefix
    
    try:
        # Validate JWT token with auth service
        user_data = await auth_client.validate_token(bearer_token)
        
        # Attach auth context to request
        request.state.user = user_data
        request.state.bearer_token = bearer_token
        
        logger.debug(f"Authenticated user {user_data.get('subject', 'unknown')}")
        
    except Exception as e:
        logger.error(f"Authentication failed: {e}")
        return JSONResponse(
            status_code=401,
            content={"error": "Invalid or expired token"}
        )
    
    # Proceed with authenticated request
    response = await call_next(request)
    return response